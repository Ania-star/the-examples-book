= TDM 20100: Project 2 -- Manipulating the Filesystem

**Motivation:** In the previous project we took a minute to get re-familiarized with working on Anvil before diving straight into the CLI, learning how to move around the filesystem. Now that we know how to move around, we are ready to learn how to manipulate the filesystem. By learning to create, destroy, and move files and directories, along with some basic commands to begin to analyze files, we will be well on our way to performing some primitive forms of data analysis using nothing but the terminal!

**Context:** The ability to use `cd`, `pwd`, and `ls` to orient yourself in the filesystem, along with a basic understanding of `man` pages, will make this project drastically easier on you.

**Scope:** Anvil, Jupyter Labs, CLI, Bash, GNU, filesystem manipulation

.Learning Objectives:
****
- Learn how to create and destroy files from the CLI
- Learn how to create and destroy directories from the CLI
- Learn how to move files and directories around the filesystem
- Learn about basic file analysis commands
****

Make sure to read about, and use the template found xref:templates.adoc[here], and the important information about project submissions xref:submissions.adoc[here].

== Dataset(s)

This project will use the following dataset(s):

- Ipsum lorem

== Questions

=== Question 1 (2 pts)

To start, let's establish a convention that will make your work on these next few projects _much_ easier. Any time that we can, we should keep all of our work in one place: the `$SCRATCH` directory. Not only will this help you keep track of everything, but it will also make sure that you don't accidentally delete any of your projects by mistake (assuming you keep your projects in your `$HOME` directory, as many do). So just remember to start your code cells off with `cd $SCRATCH` whenever appropriate, and never be afraid to `pwd` a whole bunch to be sure that you're in the right place.

Let's talk about creating and removing files. As you'll see with many things in the terminal there are a lot of different ways to accomplish the same task.

First off, the creation of files. While our more Bash-savvy students may say "Just open your favorite text editor and it'll make a new file for you!", we are going to refrain from discussing CLI text-editors like Vim and Nano, as their applications would not be very directly helpful for this class. Instead, we'll discuss the `touch` command. Creating a file is as easy as using `touch filename` to create a new file called `filename` in your current working directory (the one printed by `pwd`). However, it is often best practice to make sure that your file has the proper extension (like `.txt`, `.xdocx`, `.pdf`, and more!) in order to ensure the computer knows how to open your file.

Deletion of files is similarly easy using the `rm` command, where `rm filename` will delete a given file. Both `touch` and `rm` have their fair share of optional arguments, which you can examine in detail by viewing their respective man pages (using `man touch`, for example). Be sure to exercise _great_ caution when using `rm`, as this isn't like dropping a file into the recycling bin on your desktop. When you `rm` a file it is gone. Permanently. End of discussion. Do _not_ use `rm` before being sure that you're okay with deleting what you're deleting, and be sure you understand any arguments you may be using.

[IMPORTANT]
====
For an added degree of caution, you can use `rm -i` to be prompted before the final removal of a file. This is a good safeguard when just starting out with `rm`
====

Thirdly, let's discuss putting content into files. While once again this can be done with text editors, this course will not focus on the manual population of file contents and will instead deal with processing and managing data using tools. By-hand manipulation of real-world data is, after-all, completely impractical!

Try running the following code, which creates a file named `start.txt` in your scratch directory, adds the text "The meaning of life is the number 42." to the file, `echo`s the contents of the file to the console, and then removes the file.

[source, python]
----
%%bash
cd $SCRATCH

touch starter.txt # create the file starter.txt
echo "The meaning of life is the number 42." >  starter.txt # add contents to starter.txt
echo " -------------------------- " # spacer
cat starter.txt # print contents of file
rm -i starter.txt # -i for an extra layer of caution
----

For this question, we want you to write code that creates a new file called `greeting.txt` in your scratch directory, fills in the file with the text "Hello World!", prints the contents of the file, and then removes the file. Feel free to do this all in one cell, or spread among multiple cells if you prefer. Feel free to refer to the above example code for a _very_ big headstart into this question.

.Deliverables
====
- Bash to create, populate, then delete `greeting.txt` as specified
====

=== Question 2 (2 pts)

Next let's discuss creating directories. After all, computers have a _lot_ of files. We would be limited in a lot of ways if we stored everything in one place.

Creating directories can be done using `mkdir`. For example, `mkdir fakefolder` would create a new directory called `fakefolder`. By using `rmdir`, we can easily remove directories.

Run the below example step-by-step, examining the outputs of each step.

[source, python]
----
%%bash
cd $SCRATCH

# Step 1 - Show the directory doesn't exist
ls -l

# Step 2 - Create the directory, and show it exists
mkdir fakefolder
ls -l

# Step 3 - Delete the directory, and show it no longer exists
rmdir fakefolder
ls -l
----

Next, let's take a look at a more complex example. While `rmdir` is capable of deleting empty directories, it struggles with directories that still have contents we also want to delete. Run the below example, and observe the resulting error:

[source, python]
----
%%bash
cd $SCRATCH
mkdir fakefolder
touch fakefolder/fakefile
rmdir fakefolder
----

For directories with contents, we'll have to refer back to trusty old `rm`. Passing the recursive flag, `-r`, to `rm` will cause it to delete a directory and all its contents. With that knowledge in mind, take another few seconds to recognize the amount of damage one could accidentally due with misuse of these commands. Once you've reflected on the possible consequences of using `rm` without caution, try and complete the below activities.

. Create a directory called `emptycase` in the scratch directory
. Remove `emptycase` and then list the contents of `$SCRATCH`
. Create a directory called `fullcase` in the scratch directory
. Create a new file, `contents.txt`, within `fullcase`
. List the contents of `$SCRATCH`, then list the contents of `fullcase`
. Remove `fullcase` using the recursive argument to `rm`
. List the contents of `$SCRATCH`


.Deliverables
====
- Commands to complete the above 7 steps
====

=== Question 3 (2 pts)

Ipsum lorem dolor sit amet, consectetur adipiscing elit

.Deliverables
====
- Ipsum lorem
====

=== Question 4 (2 pts)

Ipsum lorem dolor sit amet, consectetur adipiscing elit

.Deliverables
====
- Ipsum lorem
====

=== Question 5 (2 pts)

Ipsum lorem dolor sit amet, consectetur adipiscing elit

.Deliverables
====
- Ipsum lorem
====

== Submitting your Work

This is where we're going to say how to submit your work. Probably a bit of copypasta.

.Items to submit
====
- Ipsum lorem
- Ipsum lorem
====

[WARNING]
====
You _must_ double check your `.ipynb` after submitting it in gradescope. A _very_ common mistake is to assume that your `.ipynb` file has been rendered properly and contains your code, markdown, and code output even though it may not. **Please** take the time to double check your work. See https://the-examples-book.com/projects/submissions[here] for instructions on how to double check this.

You **will not** receive full credit if your `.ipynb` file does not contain all of the information you expect it to, or if it does not render properly in Gradescope. Please ask a TA if you need help with this.
====