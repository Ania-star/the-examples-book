= TDM 20100: Project 1 -- Welcome to the CLI!

**Motivation:** The _Command Line Interface_, often referred to simply as the _CLI_, is the bread-and-butter of working with computers. With it, we can navigate through files, search for patterns, create, modify, and delete thousands of files with a single line of code, and more! In the next few projects we'll be taking some time to review the basics of Anvil (as its been a long summer!) before learning all about the CLI and what it is capable of. In just a few weeks, you'll be well on your way to mastery of the command line!

**Context:** Experience working in Anvil will make this project easier to start but is not a prequisite.

**Scope:** Anvil, Jupyter Labs, CLI, Bash, GNU

.Learning Objectives:
****
- Remember how to work in Anvil
- Learn how to navigate the CLI
- Learn how to navigate a filesystem in the CLI
****

Make sure to read about, and use the template found xref:templates.adoc[here], and the important information about project submissions xref:submissions.adoc[here].

== Dataset(s)

This project will use the following dataset(s):

- Ipsum lorem

== Questions

=== Question 1 (2 pts)

It's been a long summer, so let's start our first project this semester off with a quick review of https://www.rcac.purdue.edu/compute/anvil[Anvil]. In case you haven't already, visit https://ondemand.anvil.rcac.purdue.edu[ondemand.anvil.rcac.purdue.edu] and log in using your ACCESS account credentials. If you don't already have an account, follow [these intructions] to set one up. If you've forgotten your account credentials or are having other issues related to Anvil, please reach out to datamine-help@purdue.edu with as much information as possible about your issue.

[IMPORTANT]
====
Your ACCESS account credentials may not necessarily be the same as your Purdue Career account.
====

Once logged in, start a new Anvil session for a few hours (try not to use more than 3 for the moment) and at most 2 CPU cores.

[NOTE]
====
For a reminder on how to start a new session on Anvil:

In the upper-middle part of your screen, you should see a dropdown button labeled `The Data Mine`. Click on it, then select `Jupyter Notebook` from the options that appear. If you followed all the previous steps correctly, you should now be on a screen that looks like this:

image::f24-101-p1-1.png[OnDemand Jupyter Lab, width=792, height=500, loading=lazy, title="OnDemand Jupyter Lab"]

If your screen doesn't look like this, please try and select the correct dropdown option again or visit seminar for more assistance.
====

For this first question, we're going to have you get used to working with Jupyter. To start, upload https://the-examples-book.com/projects/_attachments/project_template.ipynb[this project template] to Jupyter and fill in your name and the project number as needed, selecting `seminar` as your https://the-examples-book.com/starter-guides/tools-and-standards/unix/jupyter-lab-kernels[kernel].

Then, run the following Python in a code cell. For a more in-depth reminder on working in Jupyter, feel free to take a look at https://the-examples-book.com/projects/fall2024/10100/10100-2024-project1[this year's 10100 project 1] or https://the-examples-book.com/starter-guides/tools-and-standards/jupyter[this guide on Jupyter].

[source, Python]
----
print("Hello World!")
----

Then, in a new code cell, run the following:

[source, Python]
----
%%bash

echo Hello World!
----

While you may not have realized it, you've just started your foray into the Command Line Interface! Let's break down the above code. The first line, `%%bash`, is _cell magic_, which tells our kernel to expect a different language than the default (In this case, the default is Python and we are telling it to expect Bash instead). The second line consists of `echo Hello World!`. `echo` is a Bash command similar to `print()` in Python, and we have it print "Hello World!"

As for https://en.wikipedia.org/wiki/Bash_(Unix_shell)[Bash] (short for _Bourne-Again-SHell_), you can think of it as a programming language for the command line. Bash has a _lot_ of handy tools and commands to learn, and the rest of this project will be spent beginning to learn about Bash.

The _terminal_ is what we call the area we typically work with the CLI in. While we can run Bash in our Jupyter notebook (as we did above), you will typically work directly in a terminal and throughout this semester we would recommend that you first run your Bash code in a terminal before copying the finished code over to your Jupyter notebook. To open a terminal on Anvil, open a new tab and select `Terminal`, where you'll be greeted with a window that looks somewhat like the following (albeit `jaxmattfair` will be replaced by your access username.)

image::f24-201-p1-1.png[OnDemand Terminal, width=792, height=500, loading=lazy, title="OnDemand Terminal"]

Try typing `echo Hello World!` and hitting enter. You should see the terminal print "Hello World!" before waiting for another command. 

To get credit for this question, write a command using `echo` that prints "Hello X!" where "X" is replaced with your name. Be sure to copy your finished command into your Jupyter notebook and run it using _cell magic_ to get credit for your work.

.Deliverables
====
- A command to print "Hello myname!" and the results of running it
====

=== Question 2 (2 pts)

Okay, at this point you probably have a decent idea of how the terminal works. We give it a line of Bash code, we hit enter, and it runs the code. But what if I was to ask you *where* your terminal is running. That may seem like a bit of a nonsense question, so let's investigate over the course of the next two questions.

The terminal we are referring to is simply where you type your input and receive your output. The _shell_, however, is the entity that is actually running your code. If you were to open another terminal tab on Anvil, and then try and reference a variable you defined in the first tab, nothing would happen. This is because the two different tabs are different _shells_, and are largely self-contained (more on this in the future). For a more concrete example, each code cell with the `%%bash` cell magic uses its own shell. When you 'run' the cell, Anvil is really starting a new shell, feeding it all the lines of code it contains, and then 'killing' the cell upon the code completing. Because of this, you'll often find it useful to test and develop all your code in a terminal tab where your work will be preserved from line-to-line and then pasting your completed commands into a notebook cell for your final deliverable.

Let's examine this idea of separate shells in detail. Try running this code all in one cell:

[source, Python]
----
%%bash

fakecommand='echo foobar'
$fakecommand
----

Observe the results. Then, in a new code cell, run:

[source, Python]
----
%%bash

$fakecommand
----

Again, observe the results. You should notice that in the first cell, where we run `fakecommand='echo foobar'` to define a variable named fakecommand, when we run `$fakecommand` it is the same as running `echo foobar`. However, in the second code cell, nothing happens when we run `$fakecommand` because each cell creates its own shell each time it runs - that is to say, the `fakecommand` variable does not exist outside the cell it is defined in. Keep this in mind going forward, as it is a common source of bugs when using Bash with Jupyter notebooks.

The other notable new concept introduced in the above code is variables. In Bash, variables are not nearly as commonly used as in languages like Python or R (for reasons we'll discuss later in the course). However, they can still be useful at times. Defining variables in Bash generally takes the form of `variablename=value` or, if there are spaces in the `value` field, `variablename='value with spaces'`. Notice the single quotes around the value. This is so that our shell knows that everything within the quotes is part of the variable, and not something else on the same line. Bash has a lot of long, single-lined commands, so this is an important distinction. By running `$variablename`, we essentially run the code assigned as the value of that variable.

For an example hinting at the practicality of this, you can do something like below:

[source, Python]
----
%%bash

e="A very long string that we want to print a bunch of times but we don't have to write a bunch of times"
echo $e
echo $e
----

Pretty interesting! We can use variables to shorten long strings! The below code is one way you could find the location of the first letter 'Z' in a file, given the file's name. The third line of code shows an example of using it. For this question, assign the long filename to a variable called `FileName`, and then use the command on the file. Starter code has been provided below, and you only have to fill in the specified lines. You will know your code is correct if it prints the same thing twice.

Once this is working, run the command again, replacing the `'Z'` with a `'J'`. You should get different results.

[source, Python]
----
%%bash

# general structure of the command
grep -n -m 1 'Z' filename

# specific demo
grep -n -m 1 'Z' /anvil/projects/tdm/data/olympics/athlete_events.csv

# starter code
# [FILL IN THIS LINE WITH YOUR VARIABLE ASSIGNMENT]
grep -n -m 1 'Z' $FileName

# [FILL IN THIS LINE, REPLACING 'Z' with 'J']
----

.Deliverables
====
- The results of running the provided code, with the proper variable assignment
====

=== Question 3 (2 pts)

Now that we understand the concepts of shells and variables more, let's answer that question we posed a bit ago: "Where are we?" Run the following code in a markdown cell:

[source, Python]
----
%%bash

pwd
----

You likely see something similar to `/home/x-username`. If the project you're currently working on is within a folder, you may see something more like `/home/x-username/foldername`. The command we just ran, `pwd`, stands for _Print Working Directory_, and it shows us where we are! On the command line, we can think of our computer of being made up of two things: files (like `firstname_lastname_project1.ipynb` or `data.csv`) and directories (basically 'folders' that contain files). The list of folders we're inside of, in-order, is referred to as our _filepath_ or just _path_. `pwd` will print your current path.

Try opening a new terminal window. Run `pwd` again. Is it the same as when you ran it in your Jupyter notebook?

.Deliverables
====
- The results of running `pwd` in a Jupyter notebook code cell
- In a markdown cell, the results of running `pwd` in a new Terminal window
====

=== Question 4 (2 pts)

Okay, now we know where we are. That's progress! However, similar to life, knowing where you are is a lot more useful when you also know what's around you and where you want to go! Try running the following command:

[source, Python]
----
%%bash
pwd
ls
----

If you use Jupyter's built-in file explorer to take a look at where your shell is, it should be rather clear that `ls` (short for list) is simply listing all of the files in that directory.

.Deliverables
====
- Ipsum lorem
====

=== Question 5 (2 pts)

Ipsum lorem dolor sit amet, consectetur adipiscing elit

.Deliverables
====
- Ipsum lorem
====

== Submitting your Work

This is where we're going to say how to submit your work. Probably a bit of copypasta.

.Items to submit
====
- Ipsum lorem
- Ipsum lorem
====

[WARNING]
====
You _must_ double check your `.ipynb` after submitting it in gradescope. A _very_ common mistake is to assume that your `.ipynb` file has been rendered properly and contains your code, markdown, and code output even though it may not. **Please** take the time to double check your work. See https://the-examples-book.com/projects/submissions[here] for instructions on how to double check this.

You **will not** receive full credit if your `.ipynb` file does not contain all of the information you expect it to, or if it does not render properly in Gradescope. Please ask a TA if you need help with this.
====