# Python {#python}

## Getting started {#getting-started-with-python}

### Python on Scholar {#python-on-scholar}

Each year we provide students with a working Python kernel that students are able to select and use from within https://notebook.scholar.rcac.purdue.edu/ as well as within an Rmarkdown document in https://rstudio.scholar.rcac.purdue.edu/. We ask that students use this kernel when completing all Python-related questions for the course. This ensures version consistency for Python and all packages that students will use during the academic year. In addition, this enables staff to quickly modify the Python environment for all students should the need arise.

Let's configure this so every time you access https://notebook.scholar.rcac.purdue.edu/ or https://rstudio.scholar.rcac.purdue.edu/, you will have access to the proper kernel, and the default version of python is correct. Navigate to https://rstudio.scholar.rcac.purdue.edu/, and login using your Purdue credentials.  In the menu, click `Tools > Shell...`. 

You should be presented with a shell towards the bottom left. Click within the shell, and type the following followed by pressing Enter or Return:

`/class/datamine/apps/runme`

After executing the script, in the menu, click `Session > Restart R`. 

In order to run Python within https://rstudio.scholar.rcac.purdue.edu/, log in to https://rstudio.scholar.rcac.purdue.edu/ and run the following in the Console or in an R code chunk:

```{r, eval=F}
datamine_py()
install.packages("reticulate")
```

The function `datamine_py` "activates" the Python environment we have setup for the course. Any time you want to use our environment, simply run the R function at the beginning of any R Session, _prior_ to running anything Python code chunks.

To test if the Python environment is working within https://rstudio.scholar.rcac.purdue.edu/, run the following in a Python code chunk:

```{python, eval=F}
import sys
print(sys.executable)
```

The python executable should be located in the appropriate folder in the following path: `/class/datamine/apps/python/`.

The `runme` script also adds a kernel to the list of kernels shown in https://notebook.scholar.rcac.purdue.edu/. 

To test if the kernel is available and working, navigate to https://notebook.scholar.rcac.purdue.edu/, login, click on `New`, and select the kernel matching the current year. For example, you would select `f2020-s2021` for the 2020-2021 academic year. Once the notebook has launched, you can confirm the version of Python by running the following in a code cell:

```{python, eval=F}
import sys
print(sys.executable)
```

The python executable should be located in the appropriate folder in the following path: `/class/datamine/apps/python/`.

If you already have a a Jupyter notebook running at https://notebook.scholar.rcac.purdue.edu/, you may need to refresh in order for the kernel to appear as an option in `Kernel > Change Kernel`.

If you would like to use the Python environment that is put together for this class, from within a terminal on Scholar, run the following:

```{bash, eval=F}
source /class/datamine/apps/python.sh
```

This will load the environment and `python` will launch our environment's interpreter.

## Variables {#p-variables}

Variables are declared just like in R, but rather than using `<-` and `->`, Python uses a single `=` as is customary for most languages. You can declared variables like this:

```{python, eval=T}
my_var = 4
```

Here, we declared a variable with a value of 4.

**Important note:** _Actually_ this is _technically_ not true. Numbers between -5 and 256 (inclusive) are already pre-declared and exist within Python's memory _before_ you assigned the value to `my_var`. The `=` operator simply forces `my_var` to _point_ to that value that already exists! That is right, `my_var` is technically a pointer. 

One extremely important distinction between declaring variables in Python vs. in R is what is actually happening under the hood. Take the following code:

```{python, eval=T}
my_var = 4
new_var = my_var
my_var = my_var + 1
print(f"my_var: {my_var}\nnew_var: {new_var}")

my_var = [4,]
new_var = my_var
my_var[0] = my_var[0] + 1
print(f"my_var: {my_var}\nnew_var: {new_var}")
```

Here, the first chunk of code behaves as expected because `int`s are immutable, meaning the values cannot be changed. As a result, when we assign `my_var = my_var + 1`, `my_var`'s _value_ isn't changing, `my_var` is just being pointed to a different value of 5, which is _not_ where `new_var` points. `new_var` still points to the value of 4.

The second chunk however is dealing with a mutable `list`. We first assign the first value of our list to a value of 4. Then we assign `my_var` to `new_var`. This does _not_ copy the values of `my_var` to `new_var`, but rather `new_var` now points to the same exact object. Then, when we increment the first value in `my_var`, that same change is reflected when we print the value in `new_var`, because `new_var` and `my_var` are the same object, i.e. `new_var is my_var`.

An excellent article that goes into more detail can be found [here](https://realpython.com/pointers-in-python/). 

### None {#p-none}

`None` is a keyword used to define a null value. This would be the Python equivalent to R's `NULL`. If used in an if statement, `None` represents `False`. This does not mean `None` == `False`, in fact:

```{python}
print(None == False)
```

As you can see, although `None` can represent `False` in an if statement, they are _not_ equivalent.

### bool {#p-bool}

A `bool` has two possible values: `True` and `False`. It is important to understand that technically:

```{python}
print(True == 1)
print(False == 0)
```

With that being said, `True` is _not_ equal to numbers greater than 1:

```{python}
print(True == 2)
print(True == 3)
```

With that being said, numbers not equal to 0 evaluate to `True` when used in an if statement:

```{python}
if 3:
  print("3 evaluates to True")
  
if 4:
  print("4 evaluates to True")
  
if -1:
  print("-1 evaluates to True")
```

### str {#p-str}

`str` are strings in Python. Strings are "immutable sequences of Unicode code points". Strings can be surrounded in single quotes, double quotes, or triple quoted (with either single or double quotes):

```{python}
print(f"Single quoted text is type: {type('test')}")
print(f'Double quoted text is type: {type("test")}')
print(f"Triple quoted with single quotes: {type('''This is some text''')}")
print(f'Triple quoted with double quotes: {type("""This is some text""")}')
```

Triple quoted strings can span multiple lines. All associated whitespace will be incorporated in the string:

```{python}
my_string = """This text
spans multiple 
lines."""
print(my_string)
```

But, this would cause an error:

```{python, eval=F}
my_string = "This text, 
will throw an error"
print(my_string)
```

But, you could make it span multiple lines by adding a `\`, but newlines won't be maintained:

```{python, eval=T}
my_string = "This text, \
will throw an error"
print(my_string)
```

### int {#p-int}

`int`'s are whole numbers. For instance:

```{python}
my_var = 5
print(type(my_var))
```

`int`'s can be added, subtracted, and multiplied without changing types. With that being said, division of 2 `int`'s results in a `float` regardless of whether or not the result of the division is a whole number or not:

```{python}
print(type(6+2))
print(type(6-2))
print(type(6*2))
print(type(6/2))
```

Similarly, any calculation between an `int` and `float` results in a `float`:

```{python}
print(type(6+2.0))
print(type(6-2.0))
print(type(6*2.0))
print(type(6/2.0))
```

### float {#p-float}

`float`'s are floating point numbers, or numbers with decimals. 

```{python}
my_var = 5.0
print(type(my_var))
```

`float`'s can be converted back to `int`'s using the `int` function. This _coercion_ causes the `float` to be truncated, regardless of how close to the "next" number the float is:

```{python}
print(int(5.5))
print(int(5.49))
print(int(5.51))
print(int(5.99999))
```

### complex {#p-complex}

`complex`'s represent complex numbers. `j` can be used to represent an imaginary number. `j` must be preceded by a number, like `1j`.

```{python}
my_var = 1j
print(my_var)
print(type(my_var))
```

Arithmetic with a `complex` always results in a `complex`:

```{python, eval=T}
print(type(1j*2))
print(type(1j*2.0))
print(type(1j*1j))
```

You cannot convert to an `int` or `float`:

```{python, eval=F}
print(int(1j*1j))
print(float(1j*1j))
```

#### Resources

**[Pointers in Python](https://realpython.com/pointers-in-python/)**

An excellent article explaining what happens under the hood when declaring variables in Python.

## Printing {#p-printing}

`print` is a function in Python that allows you to... well... print. Printing values and information about a program while the program is running is still to this day one of the best methods to debug your code. This is just one good reason to learn about and feel comfortable with printing.

You can print simple string literals:

```{python, eval=T}
print("This is a simple string literal being printed...")
```

You can print all types of variables, not just strings:

```{python, eval=T}
print(int(4))
print(float(4.4))
print(False)
```
You can even mix and match what you print:

```{python, eval=T}
print("This is a string and an int:", int(4)) # notice there is a space added between the arguments to print
print("This is a string and an int and a float:", int(4), float(4.4))
print(int(4), "<- is an integer")
```

You can even do arithmetic _inside_ the `print` function:

```{python, eval=T}
print("4 + 4 =", 4+4)
```
There are a series of special characters called [escape characters](https://www.w3schools.com/python/gloss_python_escape_characters.asp) that need to be escaped with a `\`, but that represent a different symbol when processed. For example, a newline character is `\n`, but when you print `\n` it results in a new line:

```{python, eval=T}
print("This is line 1.\nThis is line 2.")
```
Here are a couple more escape characters:

```{python, eval=T}
print("This is a carriage return\rAs you can see it is not a visible character.")
print("This is a .\tAnd another.\tAnd now two tabs.\t\tNice.")
```

You may now be wondering, well what if I want to literally print `\t` or `\n`? There are a couple of options:

```{python, eval=T}
print("You can escape a forward slash with another forward slash: \\")
print("This would then look like: \\t \\n")
print(r"You could also add an 'r' before your string. The 'r' represents raw and will render the text literally: \t \n")
```

Similarly, if you want to use double or single quotes within double or single quotes you can escape them as well:

```{python, eval=T}
print("This sentence has \"double quotes\".")
print('This sentence has \'single quotes\'.')
```

Of course, you can mix and match quotes to avoid needing to escape:

```{python, eval=T}
print('Now it is easy to print "double quotes".')
print("Now it is easy to print 'single quotes'.")
```

### f-strings {#p-f-strings}

f-strings are extremely straightforward, useful, and fast. I would highly recommend using f-strings when the need arrives to print something more than simple text.

f-string stands for "format string". An f-string is a string literal that starts with an `f` or an `F`:

```{python, eval=T}
print(f'This is an f-string.')
print(F'This is an f-string.')
```

Of course, you can use double or single quotes, like normal:

```{python, eval=T}
print(f"This still works.")
print(F"So does this.")
```

What do f-strings do? They allow you to print expressions inline:

```{python, eval=T}
print(f"4+4={4+4}")
```
They allow you to call functions:

```{python, eval=T}
def sum(a, b):
  return(a+b)
  
print(f"4+4={sum(4,4)}")
```

Overall, they are just a really nice feature that makes printing a pleasure. You can even write multi-line f-strings:

```{python, eval=T}
first = 'First'
second = 'Second'
multiline_string = f"First line {first}." \
                    "Second line {second}."
print(multiline_string)
```
But make sure you put an `f` before each line.

```{python, eval=T}
first = 'First'
second = 'Second'
multiline_string = f"First line {first}." \
                   f"Second line {second}."
print(multiline_string)
```

Better yet, use triple quotes with the f-string to handle multiline f-strings:

```{python, eval=T}
multiline_string = f"""First line {first}.
Second line {second}."""
print(multiline_string)
```

Of course, this is not _all_ f-strings are capable of. The "format" comes from somewhere. We can format our dates and times:

```{python, eval=T}
import datetime
dt = datetime.datetime.now()
print(f'This is the datetime: {dt: %Y/%m/%d %H:%M}')
```

As you can see, the content following the `:` is used to specify the format. For numbers, you can specify the number of decimals:

```{python, eval=T}
my_float = 444.44444445
print(f'My float: {my_float:.3f}')
print(f'My float: {my_float:.5f}')
```

Or if you desire leading zeros:

```{python, eval=T}
my_float = 444.44444445
print(f'My float: {my_float:010.3f}')
print(f'My float: {my_float:010.5f}')
print(f'My float: {my_float:10.5f}')
```

Note that the first `0` means "zero pad", and the following `10` represents the total width of the result. In this case it means zero pad until the full number takes up 10 characters (including the decimal place). You could remove the intial `0` if you want to make numbers line up neatly:

```{python, eval=T}
my_float = 444.44444445
print(f'My float: {555.55}')
print(f'My float: {22}')
print(f'My float: {1234.5}')

# vs
print("\nvs.\n")

print(f'My float: {555.55:7.02f}')
print(f'My float: {22:7.02f}')
print(f'My float: {1234.5:7.02f}')
```

#### Resources

**[RealPython f-strings](https://realpython.com/python-f-strings/#f-strings-a-new-and-improved-way-to-format-strings-in-python)**

A good walkthrough on f-strings.

## Logical operators {#p-logical-operators}

Logical operators are symbols that can be used within Python to make comparisons.

Operator | Description
---------|------------
`<`      | less than
`<=`     | less than or equal to
`>`      | greater than
`>=`     | greater than or equal to
`==`     | equal to
`!=`     | not equal to
`not x`     | negation, not x
`x or y`    | x OR y
`x and y`    | x AND y
`x is y` | x and y both point to the same objects in memory
`x == y` | x and y have the same values

It may be important to give a quick example of the difference between `==` and `is`:

```{python, eval=T}
x = -5
y = -5
print(x==y) # True
print(x is y) # True

x = 256
y = 256
print(x==y) # True
print(x is y) # True

x = 257
y = 257
print(x==y) # True
print(x is y) # False
```

This may be a surprising result for some of you. What is going on here? Well, Python makes an optimization where numbers between -5 and 256 (inclusive) are already declared internally. When you assign one of those pre-declared values to a variable, the variable points to the already declared object, rather than re-declaring the object. This is why the `is` operator is `True` for the first two numbers, and `False` for 257 -- x and y literally point to the same object when `is` results in `True` and does _not_ when `is` results in `False`.

```{python, eval=T}
x = -5
y = -5
print(x==y) # True
print(x is y) # True
print(id(x))
print(id(y))

x = 256
y = 256
print(x==y) # True
print(x is y) # True
print(id(x))
print(id(y))

x = 257
y = 257
print(x==y) # True
print(x is y) # False
print(id(x))
print(id(y))
```
There are a variety of interesting behaviors highlighted in [this](https://codeburst.io/the-unseen-pitfalls-of-python-7ca57f021d08) excellent article. It would be well worthwhile to read it.

## Lists & Tuples {#p-lists-and-tuples}

Lists and tuples are two of the primary data types in Python. 

### Indexing {#p-indexing}

### List methods {#p-list-methods}

The following is a table of list methods from [w3schools.com](https://www.w3schools.com/python/python_lists_methods.asp).

|Method|Description|
|------|-----------|
|append()|Adds an element at the end of the list|
|clear()|Removes all the elements from the list|
|copy()|Returns a copy of the list|
|count()|Returns the number of elements with the specified value|
|extend()|Add the elements of a list (or any iterable), to the end of the current list|
|index()|Returns the index of the first element with the specified value|
|insert()|Adds an element at the specified position|
|pop()|Removes the element at the specified position|
|remove()|Removes the item with the specified value|
|reverse()|Reverses the order of the list|
|sort()|Sorts the list|

### Tuple methods

The following is a table of tuple methods from [w3schools.com](https://www.w3schools.com/python/python_ref_tuple.asp).

|Method|Description|
|------|-----------|
|count()|Returns the number of times a specified value occurs in a tuple|
|index()|Searches the tuple for a specified value and returns the position of where it was found|

## Dicts {#p-dicts}

Dictionaries, commonly referred to as dicts, are used to store _key:value_ pairs. Under the hood, dicts are [hash tables (or hash maps)](https://en.wikipedia.org/wiki/Hash_table). Even with extremely large sets of data, dicts are able to _very_ quickly add, remove, and search for data on average. Dicts are able to accomplish this at the expense of space.

There are two ways to declare a dict, you can either use an empty or populated set of curly braces `{}`, or the `dict` keyword. 

```{python}
# Declaring dicts
my_dict_01 = {}
print(type(my_dict_01))

my_dict_02 = dict()
print(type(my_dict_02))

my_dict_03 = {"first_names": ["John", "Jill",], "last_names": ["Smith", "Johnson", "Chen"]}
print(type(my_dict_03))

my_dict_04 = dict(first_names=["John", "Jill",], last_names=["Smith", "Johnson", "Chen"])
print(type(my_dict_04))
```

Be careful! Dicts are not the only data type that utilizes the curly braces. The following is _not_ a dict, but rather a set.

```{python}
not_a_dict = {"John", "Jill", "Ellen",}
print(type(not_a_dict))
```
There are two primary ways to "get" information from a dict. One is to use the `get` method, the other is to use square brackets and strings.

```{python, eval=F}
my_dict = {"fruits": ["apple", "orange", "pear"], "person": "John", "vegetables": ["carrots", "peas"]}

# If "person" is indeed a key, they will function the same way
my_dict["person"]
my_dict.get("person")

# If the key does not exist, like below, they will not 
# function the same way.
my_dict.get("height") # Returns None when key doesn't exist
my_dict["height"] # Throws a KeyError exception because the key, "height" doesn't exist
```

The following is a table of dict methods from [w3schools.com](https://www.w3schools.com/python/python_ref_dictionary.asp).

|Method|Description|
|------|-----------|
|clear()|Removes all the elements from the dictionary|
|copy()|Returns a copy of the dictionary|
|fromkeys()|Returns a dictionary with the specified keys and value|
|get()|Returns the value of the specified key, or None if the key doesn't exist|
|items()|Returns a list containing a tuple for each key value pair|
|keys()|Returns a list containing the dictionary's keys|
|pop()|Removes and returns the element with the specified key|
|popitem()|Removes the last inserted key-value pair|
|setdefault()|Returns the value of the specified key. If the key does not exist: insert the key, with the specified value|
|update()|Updates the dictionary with the specified key-value pairs|
|values()|Returns a list of all the values in the dictionary|

## Sets {#p-sets}

The following is a table of set methods from [w3schools.com](https://www.w3schools.com/python/python_ref_set.asp).

|Method|Description|
|------|-----------|
|add()|Adds an element to the set|
|clear()|Removes all the elements from the set|
|copy()|Returns a copy of the set|
|difference()|Returns a set containing the difference between two or more sets|
|difference_update()|Removes the items in this set that are also included in another, specified set|
|discard()|Remove the specified item|
|intersection()|Returns a set, that is the intersection of two other sets|
|intersection_update()|Removes the items in this set that are not present in other, specified set(s)|
|isdisjoint()|Returns whether two sets have an intersection or not|
|issubset()|Returns whether another set contains this set or not|
|issuperset()|Returns whether this set contains another set or not|
|pop()|Removes an element from the set|
|remove()|Removes the specified element|
|symmetric_difference()|Returns a set with the symmetric differences of two sets|
|symmetric_difference_update()|Inserts the symmetric differences from this set and another|
|union()|Return a set containing the union of sets|
|update()|Update the set with the union of this set and others|

## Control flow {#p-control-flow}

### If/else statements {#p-if-else}

### For loops {#p-for-loops}

#### `enumerate` {#p-enumerate}

#### `break` {#p-break}

`break` is a keyword in Python that stops execution and immediately jumps out of the loop, continuing execution of code immediately following the end of the loop.

```{python}
my_list = list(range(1, 11))

# this will only print "1" as 
# the loop is immediately escaped when
# break is executed
for i in my_list:
  print(i)
  break
```
In the following example, we exit the loop once we get to number "5".

```{python}
my_list = list(range(1, 11))

for i in my_list:
  print(i)
  if i == 5:
    break
```

#### `continue` {#p-continue}

### List comprehensions {#p-list-comprehensions}

## Writing functions {#p-writing-functions}

## Reading & Writing data {#p-reading-and-writing-data}

### `read_csv` 

Please see [here](#p-pandas-read_csv).

### `csv` {#p-csv-pkg}

`csv` is a Python module that is useful for reading and writing tabular data. Much like the `read.csv` function in R, the `csv` module is useful for data that is _like_ csv but not necessarily comma-separated.

To use the `csv` module, simply import it:

```{python, eval=T}
import csv
```

#### Examples

##### How do you print each row of a csv `flights_sample.csv`?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
# my_csv_file is the variable holding the file
with open('flights_sample.csv') as my_csv_file:
    my_reader = csv.reader(my_csv_file)
    
    # each "row" here is a list where each 
    # value in the list is an element in the row
    for row in my_reader:
        print(row)
        
    # you can change the word "row" to anything you
    # would like, just make sure to change it everywhere!
    # first, we need to "reset" the file so it starts at the beginning
    my_csv_file.seek(0)
    for my_row in my_reader:
      print(my_row)
```
```{python}
# my_csv_file is the variable holding the file
with open('flights_sample.csv') as my_csv_file:
    my_reader = csv.reader(my_csv_file)
    # instead of printing a list, you can use the "join" 
    # string method to neatly format the output
    for this_row in my_reader:
      print(', '.join(this_row))
```
</details>

##### How do you print each row of a csv `grades_semi.csv`, where instead of being comma-separated, values are semi-colon-separated?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
with open('grades_semi.csv') as my_csv_file:
    my_reader = csv.reader(my_csv_file, delimiter=';')
    for row in my_reader:
        print(row)
```
</details>

## `pathlib` {#p-pathlib}

### `Path` {#p-pathlib-path}

#### Examples

##### How do I get the size of a file in bytes? Megabytes? Gigabytes?

```{python}
from pathlib import Path
p = Path("./5000_products.csv")
size_in_bytes = p.stat().st_size
print(f'Size in bytes: {size_in_bytes}')
print(f'Size in megabytes: {size_in_bytes/1000}')
print(f'Size in gigabytes: {size_in_bytes/1_000_000}')
```

## `numpy` {#p-numpy}

## `scipy` {#p-scipy}

## `pandas` {#p-pandas}

### `read_csv` {#p-pandas-read_csv}

`read_csv` is a function from the `pandas` library that allows you to read tabular data into a `pandas` DataFrame.

#### Examples

##### How do I read a csv file called `grades.csv` into a DataFrame? 

<details>
    <summary>Click here for solution</summary>
    
Note that the "." means the current working directory. So, if we were in "/home/john/projects", "./grades.csv" would be the same as "/home/john/projects/grades.csv". This is called a _relative_ path. Read [this](#dots) for a better understanding. 

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./grades.csv")
myDF.head()
```
</details>

##### How do I read a csv file called `grades_semi.csv` where instead of being comma-separated, it is semi-colon-separated, into a DataFrame?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./grades_semi.csv", sep=";")
myDF.head()
```
</details>

##### How do I specify the type of 1 or more columns when reading in a csv file?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./grades.csv")
myDF.dtypes

# as you can see, year is of dtype "object"
# object dtype can hold any Python object
# we know that this column should hold strings
# so let's specify this as we read in the data
myDF = pd.read_csv("./grades.csv", dtype={"year": "string"})
myDF.dtypes

# if we wanted to specify that the "grade"
# column should be float64 instead of int64
# we could do that too
myDF = pd.read_csv("./grades.csv", dtype={"year": "string", "grade": "float64"})
myDF.dtypes

# and you can see that they are indeed floats now
myDF.head()
```
</details>

##### Given a list of csv files with the same columns, how can I read them in and combine them into a single dataframe?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
my_csv_files = ["./grades.csv", "./grades2.csv"]

data = []
for file in my_csv_files:
    myDF = pd.read_csv(file)
    data.append(myDF)
    
final_result = pd.concat(data, axis=0)
final_result
```
</details>

### DataFrame {#p-pandas-dataframe}

The DataFrame is one of the primary classes used from the `pandas` package. Much like data.frames in R, DataFrames in `pandas` store tabular, two-dimensional datasets. 

Most operations involve [reading a dataset into a DataFrame](#p-pandas-read_csv), accessing the DataFrame's attributes, and using the DataFrame's methods to perform operations on the underlying data or with other DataFrames.

#### Examples

##### How do I get the number of rows and columns of a DataFrame, `myDF`?

<details>
    <summary>Click here for solution</summary>
```{python}
import pandas as pd

myDF = pd.read_csv("./flights_sample.csv")

# returns a tuple where the first value is the number of rows
# and the second value is the number of columns
myDF.shape 

# number of rows
myDF.shape[0]

# number of columns
myDF.shape[1]
```
</details>

##### How do I get the column names of a DataFrame, `myDF`?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./flights_sample.csv")
myDF.columns
```
</details>

##### How do I change the name of a column "Year" to "year"?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./flights_sample.csv")

# You must set myDF equal to the result
# otherwise, myDF will remain unchanged
myDF = myDF.rename(columns={"Year": "year"})

# Alternatively, you can use the inplace
# argument to make the change directly 
# to myDF
myDF.rename(columns={"year": "YEAR"}, inplace=True)

# As you can see, since we used inplace=True
# the change has been made to myDF without
# setting myDF equal to the result of our 
# operation
myDF.columns
```
</details>

##### How do I display the first _n_ rows of a DataFrame?

<details>
    <summary>Click here for solution</summary>
```{python, eval=F}
import pandas as pd

myDF = pd.read_csv("./flights_sample.csv")

# By default, this returns 5 rows
myDF.head()

# Use the "n" parameter to return a different number of rows
myDF.head(n=10)
```
</details>

#### Resources

**[DataFrame Reference](https://pandas.pydata.org/docs/reference/frame.html)**

A list of DataFrame attributes and methods, with links to detailed docs.

### Series {#p-pandas-series}

#### Resources

**[10 minute intro to pandas](https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html)**

A great introduction to `pandas`. Very quick.

## Jupyter notebooks {#p-jupyter-notebooks}

## Writing scripts {#p-writing-scripts}

### `argparse` {#p-argparse}

## Scraping {#p-scraping}

## XML {#p-xml}

XML stands for Extensible Markup Language. To read more about XML see [here](#xml).

### `lxml`

[`lxml`](https://lxml.de/) is a package used for processing XML in Python. To get started, simply import the package:

```{python, eval=T}
from lxml import etree
```

To load XML from a string, do the following:

```{python}
my_string = f"""<html>
    <head>
        <title>My Title</title>
    </head>
    <body>
        <div>
            <div class="abc123 sktoe-sldjkt dkjfg3-dlgsk">
                <div class="glkjr-slkd dkgj-0 dklfgj-00">
                    <a class="slkdg43lk dlks" href="https://example.com/123456">
                    </a>
                </div>
            </div>
            <div>
                <div class="ldskfg4">
                    <span class="slktjoe" aria-label="123 comments, 43 Retweets, 4000 likes">Love it.</span>
                </div>
            </div>
            <div data-amount="12">13</div>
        </div>
        <div>
            <div class="abc123 sktoe-sls dkjfg-dlgsk">
                <div class="glkj-slkd dkgj-0 dklfj-00">
                    <a class="slkd3lk dls" href="https://example.com/123456">
                    </a>
                </div>
            </div>
            <div>
                <div class="ldg4">
                    <span class="sktjoe" aria-label="1000 comments, 455 Retweets, 40000 likes">Love it.</span>
                </div>
            </div>
            <div data-amount="122">133</div>
        </div>
    </body>
</html>"""
tree = etree.fromstring(my_string)
```

Or, to load an XML file called `example.xml` do the following:

```{python}
tree = etree.parse("example.xml")
```

From there, you can use [xpath expressions](#xml-xpath) to parse the dataset.

#### Examples

##### How do I get the name of the root node from my `lxml` tree called `tree`?

<details>
    <summary>Click here for solution</summary>
```{python}
# remember "/" gets the node starting at the root node and "*" is a
# wildcard that means "anything"
tree.xpath("/*")[0].tag
```
</details>


##### If the root node is named "html", how do I get the name of all nested tags?

<details>
    <summary>Click here for solution</summary>
```{python}
list_of_tags = [x.tag for x in tree.xpath("/html/*")]
print(list_of_tags)

# remember, this odd syntax is just a "list comprehension". It is 
# essentially a nice short-hand way of writing a loop in Python.
# It is the exact same as:
for element in tree.xpath("/html/*"):
  print(element.tag)
```
</details>

##### How do I get the attributes of an element?

<details>
    <summary>Click here for solution</summary>
```{python}
import pandas as pd

# as you can see, this prints the attributes in a dict-like object for each div element
# in the node. 
for element in tree.xpath("//div"):
  print(element.attrib)
  
# Note, if you ever want to convert a list of dicts to a pandas dataframe
# you will need to convert to a dict.
list_of_dicts = []
for element in tree.xpath("//div"):
  list_of_dicts.append(element.attrib)

myDF = pd.DataFrame(list_of_dicts)
myDF.head() # unexpected

list_of_dicts = []
for element in tree.xpath("//div"):
  list_of_dicts.append(dict(element.attrib))

myDF = pd.DataFrame(list_of_dicts)
myDF.head() # fixed
```
</details>

##### How do I get the div elements with attribute "data-amount"?

<details>
    <summary>Click here for solution</summary>
```{python}
for element in tree.xpath("//div[@data-amount]"):
  print(element.attrib)
```
</details>

##### How do I get the div elements where data-amount is greater than 50?

<details>
    <summary>Click here for solution</summary>
```{python}
for element in tree.xpath("//div[@data-amount > 50]"):
  print(element.attrib)
```
</details>

##### How do I get the values of the span tags?

<details>
    <summary>Click here for solution</summary>
```{python}
for element in tree.xpath("//span"):
  print(element.text)
```
</details>

## Plotting {#p-plotting}

### `matplotlib` {#p-matplotlib}

#### Resources {#p-matplotlib-resources}

### `plotly` {#p-plotly}

### `plotnine` {#p-plotnine}

### `pygal` {#p-pygal}

### `seaborn` {#p-seaborn}

### `bokeh` {#p-bokeh}

## Classes {#p-classes}

### Attributes

### Methods

## `tensorflow`

## `pytorch`
