# R {#r}

## Getting started {#getting-started-with-r}

## Variables {#r-variables}

### NA {x}

NA stands for not available and, in general, represents a missing value or a lack of data.

#### How do I tell if a value is NA? {r-isna}

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# Test if value is NA.
value <- NA
is.na(value)

# Does is.nan return TRUE for NA?
is.nan(value)
```
</details>

### NaN {#r-nan}

NaN stands for not a number and, in general, is used for arithmetic purposes, for example, the result of 0/0.

#### How do I tell if a value is NaN?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# Test if a value is NaN.
value <- NaN
is.nan(value)

value <- 0/0
is.nan(value)

# Does is.na return TRUE for NaN?
is.na(value)
```
</details>

### Dates {#r-dates}

`Date` is a class which allows you to perform special operations like subtraction, where the number of days between dates are returned. Or addition, where you can add 30 to a `Date` and a `Date` is returned where the value is 30 days in the future.

You will usually need to specify the `format` argument based on the format of your date strings. For example, if you had a string `07/05/1990`, the format would be: `%m/%d/%Y`. If your string was `31-12-90`, the format would be `%d-%m-%y`. Replace `%d`, `%m`, `%Y`, and `%y` according to your date strings. A full list of formats can be found [here](https://www.stat.berkeley.edu/~s133/dates.html).

#### How do I convert a string "07/05/1990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_string <- "07/05/1990"
my_date <- as.Date(my_string, format="%m/%d/%Y")
my_date
```
</details>

#### How do I convert a string "31-12-1990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_string <- "31-12-1990"
my_date <- as.Date(my_string, format="%d-%m-%Y")
my_date
```
</details>

#### How do I convert a string "31-12-1990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_string <- "31-12-1990"
my_date <- as.Date(my_string, format="%d-%m-%Y")
my_date
```
</details>

### Factors {#r-factors}

A `factor` is R's way of representing a categorical variable. Each `factor` is essentially a numeric value with an associated name. They are a useful when a vector has only a few different values it could be, like "Male" and "Female" or "A", "B", or "C".

#### How do I test whether or not a value is a factor?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
test_factor <- factor("Male")
is.factor(test_factor)

test_factor_vec <- factor(c("Male", "Female", "Female"))
is.factor(test_factor_vec)
```
</details>

#### How do I convert a vector of strings to a vector of factors?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- c("Male", "Female", "Female")
vec <- factor(c("Male", "Female", "Female"))
```
</details>

#### How do I get the unique values a factor could hold, also known as _levels_?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- factor(c("Male", "Female", "Female"))
levels(vec)
```
</details>

#### How can I rename the levels of a vector of factors?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- factor(c("Male", "Female", "Female"))
levels(vec)
levels(vec) <- c("F", "M")
vec

# Be careful! Order matters, this is wrong:
vec <- factor(c("Male", "Female", "Female"))
levels(vec)
levels(vec) <- c("M", "F")
vec
```
</details>

## Logical operators {#r-logical-operators}

Logical operators are symbols that can be used within R to compare values or vectors of values. 

Operator | Description
---------|------------
`<`      | less than
`<=`     | less than or equal to
`>`      | greater than
`>=`     | greater than or equal to
`==`     | equal to
`!=`     | not equal to
`!x`     | negation, not x
`x|y`    | x OR y
`x&y`    | x AND y

### Examples

#### What are the values in a vector, `vec` that are greater than 5?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec > 5
```
</details>

#### What are the values in a vector, `vec` that are greater than or equal to 5?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec >= 5
```
</details>

#### What are the values in a vector, `vec` that are less than 5?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec < 5
```
</details>

#### What are the values in a vector, `vec` that are less than or equal to 5?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec <= 5
```
</details>

#### What are the values in a vector that are greater than 7 OR less than or equal to 2?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec > 7 | vec <=2
```
</details>

#### What are the values in a vector that are greater than 3 AND less than 6?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec > 3 & vec < 6
```
</details>

#### How do I get the values in `list1` that are in `list2`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
list1 <- c("this", "is", "a", "test")
list2 <- c("this", "a", "exam")
list1[list1 %in% list2]
```
</details>

#### How do I get the values in `list1` that are not in `list2`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
list1 <- c("this", "is", "a", "test")
list2 <- c("this", "a", "exam")
list1[!(list1 %in% list2)]
```
</details>

#### How can I get the number of values in a vector that are greater than 5?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
sum(vec>5)

# Note, you do not need to do:
length(vec[vec>5])

# because TRUE==1 and FALSE==0 in R
TRUE==1
FALSE==0
```
</details>

### Resources 

**[Operators Summary](https://www.statmethods.net/management/operators.html)**

A quick list of the various operators with a few simple examples.

## Lists & Vectors {#r-lists-and-vectors}

A vector contains values that are all the same type. The following are some examples of vectors:

```{r}
# A logical vector
lvec <- c(F, T, TRUE, FALSE)
class(lvec)

# A numeric vector
nvec <- c(1,2,3,4)
class(nvec)

# A character vector
cvec <- c("this", "is", "a", "test")
class(cvec)
```
As soon as you try to mix and match types, elements are coerced to the simplest type required to represent all the data.

The order of representation is:

logical, numeric, character, list

For example:

```{r}
class(c(F, 1, 2))
class(c(F, 1, 2, "ok"))
class(c(F, 1, 2, "ok", list(1, 2, "ok")))
```

Lists are vectors that can contain any class of data. For example:

```{r}
list(TRUE, 1, 2, "OK", c(1,2,3))
```
With lists, there are 3 ways you can index.

```{r}
my_list <- list(TRUE, 1, 2, "OK", c(1,2,3), list("OK", 1,2, F))

# The first way is with single square brackets [].
# This will always return a list, even if the content 
# only has 1 component.
class(my_list[1:2])
class(my_list[3])

# The second way is with double brackets [[]].
# This will return the content itself. If the
# content is something other than a list it will
# return the value itself.
class(my_list[[1]])
class(my_list[[3]])

# Of course, if the value is a list itself, it will
# remain a list.
class(my_list[[6]])

# The third way is using $ to extract a single, named variable. 
# We need to add names first! $ is like the double bracket,
# in that it will return the simplest form.
my_list <- list(first=TRUE, second=1, third=2, fourth="OK", embedded_vector=c(1,2,3), embedded_list=list("OK", 1,2, F))
my_list$first
my_list$embedded_list
```

## Basic R functions {#r-basic-functions}

### `dim` {#r-dim}

`dim` returns the dimensions of a matrix or data.frame. The first value is the rows, the second is columns.

#### Examples

##### How many dimensions does the data.frame `dat` have?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
dat <- data.frame("col1"=c(1,2,3), "col2"=c("a", "b", "c"))
dim(dat) # 3 rows and 2 columns
```
</details>

### `length` {#r-length}

`length` allows you to get or set the length of an object in R (for which a method has been defined).

#### How do I get how many values are in a vector?
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# Create a vector of length 5
my_vector <- c(1,2,3,4,5)

# Calculate the length of my_vector
length(my_vector)
```
</details>

### `grep`, `grepl`, etc. {#r-grep}

`grep` allows you to use regular expressions to search for a pattern in a string or character vector, and returns the index where there is a match.

`grepl` performs the same operation but rather than returning indices, returns a vector of logical `TRUE` or `FALSE` values.

#### Examples

##### Given a character vector, return the index of any words ending in "s".
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
grep("*.s$", c("waffle", "waffles", "pancake", "pancakes"))
```
</details>

##### Given a character vector, return a vector of the same length where each element is `TRUE` if there was a match for any word ending in "s", and `FALSE otherwise.
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
grepl("*.s$", c("waffle", "waffles", "pancake", "pancakes"))
```
</details>

### `mean` {#r-mean}

`mean` is a function that calculates the average of a vector of values.

#### How do I get the average of a vector of values?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
mean(c(1,2,3,4))
```
</details>

#### How do I get the average of a vector of values when some of the values are: `NA`, `NaN`?

<details>
    <summary>Click here for solution</summary>
    
Many R functions have the `na.rm` argument available. This argument is "a logical value indicating whether NA values should be stripped before the computation proceeds." 

```{r, eval=T}
mean(c(1,2,3,NaN), na.rm=T)

mean(c(1,2,3,NA), na.rm=T)

mean(c(1,2,NA,NaN,4), na.rm=T)
```
</details>

### `var` {#r-var}

`var` is a function that calculate the variance of a vector of values.

#### How do I get the variance of a vector of values?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
var(c(1,2,3,4))
```
</details>

#### How do I get the variance of a vector of values when some of the values are: `NA`, `NaN`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
var(c(1,2,3,NaN), na.rm=T)

var(c(1,2,3,NA), na.rm=T)

var(c(1,2,NA,NaN,4), na.rm=T)
```
</details>

#### How do I get the standard deviation of a vector of values?

<details>
    <summary>Click here for solution</summary>
    
The standard deviation is equal to the square root of the variance.

```{r, eval=T}
sqrt(var(c(1,2,3,NaN), na.rm=T))

sqrt(var(c(1,2,3,NA), na.rm=T))

sqrt(var(c(1,2,NA,NaN,4), na.rm=T))
```
</details>

### `unique` {#r-unique}

`unique` "returns a vector, data frame, or array like x but with duplicate elements/rows removed.

#### Given a vector of values, how do I return a vector of values with all duplicates removed?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- c(1, 2, 3, 3, 3, 4, 5, 5, 6)
unique(vec)
```
</details>

### `paste` and `paste0` {#r-paste}

`paste` is a useful function to "concatenate vectors after converting to character."

`paste0` is a shorthand function where the `sep` argument is "".

#### How do I concatenate two vectors, element-wise, with a comma in between values from each vector?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vector1 <- c("one", "three", "five")
vector2 <- c("two", "four", "six")
paste(vector1, vector2, sep=",")
```
</details>

#### How do I paste together two strings?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
paste0("abra", "kadabra")
```
</details>

#### How do I paste together three strings?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
paste0("abra", "kadabra", "alakazam")
```
</details>

### `str` {#r-str}

`str` stands for _structure_. `str` gives you a glimpse at the variable of interest. 

```{r, include=F}
df <- read.csv("test.csv")
```

#### How do I get the number of columns or features in a data.frame?

<details>
    <summary>Click here for solution</summary>
    
As you can see, there are 9 rows or obs. (short for observations), and 29 variables (which can be referred to as columns or features).
```{r, eval=F}
str(df)
```
</details>

### `str_extract` and `str_extract_all` {#r-str-extract}

`str_extract` and `str_extract_all` are useful functions from the `stringr` package. You can install the package by running:

```{r, eval=F}
install.packages("stringr")
```

`str_extract` extracts the text which matches the provided regular expression or pattern. Note that this differs from `grep` in a major way. `grep` simply returns the index in which a pattern match was found. `str_extract` returns the actual matching text. Note that `grep` typically returns the entire line where a match was found. `str_extract` returns only the part of the line or text that matches the pattern. 

For example:

```{r, eval=T}
text <- c("cat", "mat", "spat", "spatula", "gnat")

# All 5 "lines" of text were a match.
grep(".*at", text)
```

```{r, eval=T}
text <- c("cat", "mat", "spat", "spatula", "gnat")
stringr::str_extract(text, ".*at") 
```
As you can see, although all 5 words match our pattern and would be returned by `grep`, `str_extract` only returns the actual text that matches the pattern. In this case "spatula" is _not_ a "full" match -- the pattern ".\*at" only captures the "spat" part of "spatula". In order to capture the rest of the word you would need to add something like ".\*" to the end of the pattern:

```{r, eval=T}
text <- c("cat", "mat", "spat", "spatula", "gnat")
stringr::str_extract(text, ".*at.*") 
```
One final note is that you must double-escape certain characters in patterns because R treats backslashes as escape values for character constants ([stackoverflow](https://stackoverflow.com/questions/27721008/how-do-i-deal-with-special-characters-like-in-my-regex)). For example, to write `\(` we must first escape the `\`, so we write `\\(`. This is true for many character which would normally only be preceded by a single `\`.

#### Examples

##### How can I extract the text between parenthesis in a vector of texts?
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
text <- c("this is easy for (you)", "there (are) challenging ones", "text is (really awesome) (ok?)")

# Search for a literal "(", followed by any amount of any text other than more parenthesis ([^()]*), followed by a literal ")".
stringr::str_extract(text, "\\([^()]*\\)")
```

To get _all_ matches, not just the first match:
```{r, eval=T}
text <- c("this is easy for (you)", "there (are) challenging ones", "text is (really awesome) more text (ok?)")

# Search for a literal "(", followed by any amount of any text (.*), followed by a literal ")".
stringr::str_extract_all(text, "\\([^()]*\\)")
```
</details>

## Data.frames {#r-data-frames}

#### How do I sample _n_ rows randomly from a data.frame called `df`?
<details>
    <summary>Click here for solution</summary>
    
```{r, eval=F}
df[sample(nrow(df), n),]
```

Alternatively you could use the `sample_n` function from the package `dplyr`:
```{r, eval=F}
sample_n(df, n)
```
</details>

## Reading & Writing data {#r-reading-and-writing-data}

### Examples

#### How do I read a csv file called `grades.csv` into a data.frame? {r-read}

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
dat <- read.csv("./grades.csv")
head(dat)
```
</details>

#### How do I read a csv file called `grades2.csv` where instead of being comma-separated, it is semi-colon-separated, into a data.frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
dat <- read.csv("./grades_semi.csv", sep=";")
head(dat)
```
</details>

#### How do I prevent R from reading in strings as factors when using a function like `read.csv`?

<details>
    <summary>Click here for solution</summary>
In R 4.0+, strings are not read in as factors, so you do not need to do anything special. For R < 4.0, use `stringsAsFactors`.

```{r, eval=T}
dat <- read.csv("./grades.csv", stringsAsFactors=F)
head(dat)
```
</details>

#### How do I specify the type of 1 or more columns when reading in a csv file?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
dat <- read.csv("./grades.csv", colClasses=c("grade"="character", "year"="factor"))
str(dat)
```
</details>

#### Given a list of csv files with the same columns, how can I read them in and combine them into a single dataframe?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# We want to read in grades.csv, grades2.csv, and grades3.csv 
# into a single dataframe.

list_of_files <- c("grades.csv", "grades2.csv", "grades3.csv")

results <- data.frame()
for (file in list_of_files) {
  dat <- read.csv(file)
  results <- rbind(results, dat)
}
dim(results)
```
</details>

#### How do I create a data.frame with comma-separated data that I've copied onto my clipboard?

<details>
    <summary>Click here for solution</summary>
```{r, eval=F}
# For mac
dat <- read.delim(pipe("pbpaste"),header=F,sep=",")

# For windows
dat <- read.table("clipboard",header=F,sep=",")
```
</details>

## Control flow {#r-control-flow}

### If/else statements {#r-if-else}

If, else if, and else statements are methods for controlling whether or not an operation is performed based on the result of some expression. 

#### How do I print "Success!" if my expression evaluates to `TRUE`, and "Failure!" otherwise?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# Randomly assign either TRUE or FALSE to t_or_f.
t_or_f <- sample(c(TRUE,FALSE),1)

if (t_or_f == TRUE) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else {
  # Otherwise, print failure
  print("Failure!")
}

# You don't need to put the full expression.
# This is the same thing because t_or_f
# is already TRUE or FALSE. 
# TRUE == TRUE evaluates to TRUE and
# FALSE == TRUE evaluates to FALSE.
if (t_or_f) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else {
  # Otherwise, print failure
  print("Failure!")
}
```
</details>

#### How do I print "Success!" if my expression evaluates to `TRUE`, "Failure!" if my expression evaluates to `FALSE`, and "Huh?" otherwise?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# Randomly assign either TRUE or FALSE to t_or_f.
t_or_f <- sample(c(TRUE,FALSE, "Something else"),1)

if (t_or_f == TRUE) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else if (t_or_f == FALSE) {
  # If t_or_f is FALSE, print failure
  print("Failure!")
} else {
  # Otherwise print huh
  print("Huh?")
}

# In this case you need the full expression because
# "Something else" does not evaluate to TRUE or FALSE
# which will cause an error as the if and else if 
# statements expect a result of TRUE or FALSE.
if (t_or_f == TRUE) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else if (t_or_f == FALSE) {
  # If t_or_f is FALSE, print failure
  print("Failure!")
} else {
  # Otherwise print huh
  print("Huh?")
}
```
</details>

### For loops {#r-for-loops}

For loops allow us to execute similar code over and over again until we've looped through all of the elements. They are useful for performing the same operation to an entire vector of input, for example. 

Using the suite of apply functions is more common in R. It is often said that the apply suite of function are much faster than for loops in R. While this used to be the case, this is no longer true. 

#### Examples

##### How do I loop through every value in a vector and print the value?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
for (i in 1:10) {
  # In the first iteration of the loop,
  # i will be 1. The next, i will be 2.
  # Etc.
  print(i)
}
```
</details>

##### How do I break out of a loop before it finishes?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
for (i in 1:10) {
  if (i==7) {
    # When i==7, we will exit the loop.
    break
  }
  print(i)
}
```
</details>

##### How do I loop through a vector of names?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
friends <- c("Phoebe", "Ross", "Rachel", "Chandler", "Joey", "Monica")
my_string <- "So no one told you life was gonna be this way, "
for (friend in friends) {
  print(paste0(my_string, friend, "!"))
}
```
</details>

##### How do I skip a loop if some expression evaluates to `TRUE`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
friends <- c("Phoebe", "Ross", "Mike", "Rachel", "Chandler", "Joey", "Monica")
my_string <- "So no one told you life was gonna be this way, "
for (friend in friends) {
  if (friend == "Mike") {
    # next, skips over the rest of the code for this loop
    # and continues to the next element
    next
  }
  print(paste0(my_string, friend, "!"))
}
```
</details>

## Apply functions {#r-apply-functions}

### `apply` {#r-apply}

### `lapply` {#r-lapply}

### `sapply` {#r-sapply}

### `tapply` {#r-tapply}

`tapply` is described in the documentation as a way to "apply a function to each cell of a ragged array, that is to each (non-empty) group of values given by a unique combination of the levels of certain factors." This is not a very useful description. 

An alternative way to think about `tapply`, is as a function that allows you to calculate or apply `function` to `data1` when `data1` is grouped by `data2`.

`tapply(data1, data2, function)`

A concrete example would be getting the _mean_ (`function`) _grade_ (`data1`) when _grade_ (`data1`) is grouped by _year_ (`data2`):

```{r, include=F}
grades <- read.csv("grades.csv")
```

```{r, eval=T}
grades
```

```{r}
tapply(grades$grade, grades$year, mean)
```

If your `function` (in this case _mean_), requires extra arguments, you can pass those by name to `tapply`. This is what the `...` argument in `tapply` is for. For example, if we want our _mean_ function to remove na's prior to calculating a mean we could do the following:

```{r}
tapply(grades$grade, grades$year, mean, na.rm=T)
```

## Writing functions {#r-writing-functions}

## Plotting {#r-plotting}

### `barplot`

### `ggplot` {#r-ggplot}

### `ggmap` {#r-ggmap}

`ggmap` is an excellent package that provides a suite of functions that, among other things, allows you to map spatial data on top of static maps.

#### Getting started {#r-ggmap-getting-started}

To install `ggmap`, simply run `install.packages("ggmap")`. To load the library, run `library(ggmap)`. When first using this package, you may notice you need an API key to get access to certain functionality. Follow the directions [here](https://developers.google.com/maps/documentation/maps-static/get-api-key#get-key) to get an API key. It should looks somethings like: `mQkzTpiaLYjPqXQBotesgif3EfGL2dbrNVOrogg`. 

Once you've acquired the API key, you have two options:

1. Register `ggmap` with Google for the current session:

```{r, eval=F}
library(ggmap)
register_google(key="mQkzTpiaLYjPqXQBotesgif3EfGL2dbrNVOrogg")
```

2. Register `ggmap` with Google, persistently through sessions:

```{r, eval=F}
library(ggmap)
register_google(key="mQkzTpiaLYjPqXQBotesgif3EfGL2dbrNVOrogg", write=TRUE)
```

Note that if you choose option (2), your API key will be saved within your `~/.Renviron`.

#### Examples

##### How do I get a map of West Lafayette?

<details>
    <summary>Click here for solution</summary>
```{r, eval=F}
map <- get_map(location="West Lafayette")
ggmap(map)
```
</details>

##### How do I zoom in and out on a map of West Lafayette?

<details>
    <summary>Click here for solution</summary>
```{r, eval=F}
# zoom way out
map <- get_map(location="West Lafayette", zoom=1)
ggmap(map)

# zoom in
map <- get_map(location="West Lafayette", zoom=12)
ggmap(map)
```
</details>

##### How do I add Latitude and Longitude points to a map of Purdue University?

<details>
    <summary>Click here for solution</summary>
```{r, eval=F}
points_to_add <- data.frame(latitude=c(40.433663, 40.432104, 40.428486), longitude=c(-86.916584, -86.919610, -86.920866))
map <- get_map(location="Purdue University", zoom=14)
ggmap(map) + geom_point(data = points_to_add, aes(x = longitude, y = latitude))
```
</details>

## RMarkdown {#r-rmarkdown}

To install RMarkdown simply run the following:

```r
install.packages("rmarkdown")
```

Projects in [The Data Mine](https://datamine.purdue.edu) are all written in RMarkdown. You can download the RMarkdown file by clicking on the link at the top of each project page. Each file should end in the ".Rmd" which is the file extension commonly associated with RMarkdown files.

You can find an exemplary RMarkdown file here:

https://raw.githubusercontent.com/TheDataMine/the-examples-book/master/files/rmarkdown.Rmd

If you open this file in RStudio, and click on the "Knit" button in the upper left hand corner of IDE, you will get the resulting HTML file. Open this file in the web browser of your choice and compare and contrast the syntax in the `rmarkdown.Rmd` file and resulting output. Play around with the file, make modifications, and re-knit to gain a better understanding of the syntax. Note that similar input/output examples are shown in the [RMarkdown Cheatsheet](https://rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf).

### Code chunks

Code chunks are sections within an RMarkdown file where you can write, display, and optionally evaluate code from a variety of languages:

```{r, echo=FALSE}
names(knitr::knit_engines$get())
```

The syntax is simple:

````markdown
`r ''````{language, options...}
code here...
```
````

For example:

````markdown
`r ''````{r, echo=TRUE}
my_variable <- c(1,2,3)
my_variable
```
````

Which will render like:

```{r, echo=TRUE}
my_variable <- c(1,2,3)
my_variable
```

You can find a list of chunk options [here](https://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf). 

#### How do I run a code chunk but not display the code above the results?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r, echo=FALSE}
my_variable <- c(1,2,3)
my_variable
```
````
</details>

#### How do I include a code chunk without evaluating the code itself?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r, eval=FALSE}
my_variable <- c(1,2,3)
my_variable
```
````
</details>

#### How do I prevent warning messages from being displayed?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r, warning=FALSE}
my_variable <- c(1,2,3)
my_variable
```
````
</details>

#### How do I prevent error messages from being displayed?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r, error=FALSE}
my_variable <- c(1,2,3)
my_variable
```
````
</details>

#### How do I run a code chunk, but not include the chunk in the final output?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r, include=FALSE}
my_variable <- c(1,2,3)
my_variable
```
````
</details>

#### How do I render a figure from a chunk?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r}
my_variable <- c(1,2,3)
plot(my_variable)
```
````
</details>

#### How do I create a set of slides using RMarkdown?

<details>
    <summary>Click here for solution</summary>
Please see the example Rmarkdown file [here](https://raw.githubusercontent.com/TheDataMine/the-examples-book/master/files/example_slides.Rmd). 

You can change the slide format by changing the yaml header to any of: ioslides_presentation, slidy_presentation, or beamer_presentation.

By default all first and second level headers (\# and \##, respectively) will create a new slide. To manually create a new slide, you can use \*\*\*.
</details>

### Resources {#r-markdown-resources}

**[RMarkdown Cheatsheet](https://rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf)**

An excellent quick reference for RMarkdown syntax.

**[RMarkdown Reference](https://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)**

A thorough reference manual showing markdown input and expected output. Gives descriptions of the various chunk options, as well as output options.

**[RStudio RMarkdown Lessons](https://rmarkdown.rstudio.com/lesson-1.html)**

A set of lessons detailing the ins and outs of RMarkdown.

**[Markdown Tutorial](https://www.markdowntutorial.com/)**

RMarkdown uses Markdown syntax for its text. This is a good, interactive tutorial to learn the basics of Markdown. This tutorial is available in multiple languages.

**[RMarkdown Gallery](https://rmarkdown.rstudio.com/gallery.html)**

This gallery highlights a variety of reproducible and interactive RMarkdown documents. An excellent resource to see the power of RMarkdown.

**[RMarkdown Chapter](https://r4ds.had.co.nz/r-markdown.html)**

This is a chapter from Hadley Wickham's excellent [_R for Data Science_](https://r4ds.had.co.nz/) book that details important parts of RMarkdown.

**[RMarkdown in RStudio](https://rmarkdown.rstudio.com/articles_intro.html)**

This is a nice article that introduces RMarkdown, and guides the user through creating their own interactive document using RMarkdown in RStudio.

**[Reproducible Research](https://andrewbtran.github.io/NICAR/2017/reproducibility-rmarkdown/rmarkdown.html#reproducible_research)**

This is another good resource that introduces RMarkdown. Plenty of helpful pictures and screenshots.

## Tidyverse {#r-tidyverse}

### `lubridate` {#r-lubridate}

`lubridate` is a fantastic package that makes the typical tasks one would perform on dates, that much easier.

#### How do I convert a string "07/05/1990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
library(lubridate)
dat <- "07/05/1990"
dat <- mdy(dat)
class(dat)
```
</details>

#### How do I convert a string "31-12-1990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_string <- "31-12-1990"
dat <- dmy(my_string)
dat
class(dat)
```
</details>

#### How do I convert a string "31121990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_string <- "31121990"
my_date <- dmy(my_string)
my_date
class(my_date)
```
</details>

#### How do I extract the day, week, month, quarter, and year from a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_date <- dmy("31121990")
day(my_date)
week(my_date)
month(my_date)
quarter(my_date)
year(my_date)
```
</details>

### Resources {#r-lubridate-resources}

**[Lubridate Cheatsheet](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf)**

A comprehensive cheatsheet on `lubridate`. Excellent resource to immediately begin using `lubridate`.

## data.table {#r-datatable}

## SQL in R {#r-sql}

## Scraping {#r-scraping}

## `shiny` {#r-shiny}

### Rendering images {#r-shiny-render-images}


