= `tidyverse`

== case_when

`case_when` is a function that allows you to vectorize multiple `if_else` statements. For example, let's say we want to create a new column in our `iris` dataset called `size`, where the value is `Large` if `Sepal.Length` is greater than 5, and `Not Large` otherwise?

[source, r]
----
new_iris <- iris %>%
    mutate(size = case_when(
        Sepal.Length > 5 ~ "Large",
        Sepal.Length <= 5 ~ "Not Large"
    ))

head(new_iris)
----

[source, r]
----
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species      size
 1          5.1         3.5          1.4         0.2  setosa     Large
 2          4.9         3.0          1.4         0.2  setosa Not Large
 3          4.7         3.2          1.3         0.2  setosa Not Large
 4          4.6         3.1          1.5         0.2  setosa Not Large
 5          5.0         3.6          1.4         0.2  setosa Not Large
 6          5.4         3.9          1.7         0.4  setosa     Large
----

Here, `mutate` is responsible for creating a new column called `size`, and `case_when` assigns the value `Large` when `Sepal.Length` is greater than 5 and `Not Large` when `Sepal.Length` is less than or equal to `Not Large`. In this case we have exhaustively gone through all of the possible values of our new column, `size`, because for each and every possible value of `Sepal.Length` we have an associated value (`Large` and `Not Large`). In reality, this is not always possible. For example, let's remove the second case:

[source, r]
----
new_iris <- iris %>%
    mutate(size = case_when(
        Sepal.Length > 5 ~ "Large"
    ))

head(new_iris)
----

[source, r]
----
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species  size
 1          5.1         3.5          1.4         0.2  setosa Large
 2          4.9         3.0          1.4         0.2  setosa  <NA>
 3          4.7         3.2          1.3         0.2  setosa  <NA>
 4          4.6         3.1          1.5         0.2  setosa  <NA>
 5          5.0         3.6          1.4         0.2  setosa  <NA>
 6          5.4         3.9          1.7         0.4  setosa Large
----

As you can see, by default, if no cases match, NA is the resulting value. One common technique to handle "all other cases" is the following:

[source, r]
----
new_iris <- iris %>%
    mutate(size = case_when(
        Sepal.Length > 5 ~ "Large",
        TRUE ~ "Not Large"
    ))

head(new_iris)
----

[source, r]
----
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species      size
 1          5.1         3.5          1.4         0.2  setosa     Large
 2          4.9         3.0          1.4         0.2  setosa Not Large
 3          4.7         3.2          1.3         0.2  setosa Not Large
 4          4.6         3.1          1.5         0.2  setosa Not Large
 5          5.0         3.6          1.4         0.2  setosa Not Large
 6          5.4         3.9          1.7         0.4  setosa     Large
----

Here, each case is evaluated. If at the end, there was no match, `TRUE` is always a match, and therefore the result will be `Not Large`.

== between

`between` is a dead simple function from `dplyr` that is an efficiently implemented shortcut for the following:

[source, r]
----
x <- 5

print(x >= 4 && x <= 10)
----

[source, r]
----
 [1] TRUE
----

[source, r]
----
# instead you can use between
between(x, 4, 10)
----

[source, r]
----
 [1] TRUE
----

== glimpse

== filter

== arrange

== group_by

`group_by` is a function commonly used in conjunction with `mutate`, `transmute`, and `summarize`. It is useful when you want to perform a `tapply`-like operation on a data.frame. For example, let's say you wanted to get the average `Petal.Length` by `Species`. Using `tapply`, you would do something like:

[source, r]
----
tapply(iris$Petal.Length, iris$Species, mean)
----

[source, r]
----
     setosa versicolor  virginica 
      1.462      4.260      5.552
----

While useful, `tapply` 's end result isn't in a format that is conducive to further analysis or wrangling. For example, what if we wanted to calculate and then plot (in `ggplot`) the difference between the mean `Petal.Length` and the mean `Sepal.Length` by `Species`? Using `tapply`, you would have to do something like:

[source, r]
----
diff <- tapply(iris$Petal.Length, iris$Species, mean) - tapply(iris$Sepal.Length, iris$Species, mean)
myDF <- data.frame(Species = names(diff), diff = unname(diff))
ggplot(myDF, aes(x=diff, y=Species)) + geom_bar(stat="identity")
----

image::tidyverse_groupby_example_1[]

Again, a little bit more difficult to read than the following, and if you had more operations to complete, the previous example would make it difficult to do even more. In the following example, however, we can continue to utilize and build on myDF:

[source, r]
----
myDF <- iris %>%
    group_by(Species) %>%
    mutate(diff=mean(Petal.Length) - mean(Sepal.Length))

myDF %>% ggplot(aes(x=diff, y=Species)) + geom_bar(stat="identity")
----

image::tidyverse_groupby_example_2[]

== summarize

`summarize` is a useful function to get a new, tidy, data frame that is a summary of some other data. It's particularly useful in conjunction with `group_by`, when you want to compare groups.

For example, let's say you wanted to the following:

* Create a new column called `Sepal.Length.Cat` with values `small` when `Sepal.Length` < 5.1, `large` when `Sepal.Length` >= 5.8, and `medium` otherwise.
* Get a summary containing the average `Sepal.Width` by `Sepal.Length.Cat` and `Species`.
* Get a summary containing the variation in averages for each `Species`.

[source, r]
----
iris %>% 
    mutate(Sepal.Length.Cat = case_when(
        Sepal.Length < 5.1 ~ "small",
        Sepal.Length >= 5.8 ~ "large",
        TRUE ~ "medium"
    )) %>%
    group_by(Sepal.Length.Cat, Species) %>%
    summarize(avg_sepal_width_grouped = mean(Sepal.Width)) %>%
    group_by(Species) %>%
    summarize(std_of_avgs = sd(avg_sepal_width_grouped))
----

[source, r]
----
 `summarise()` regrouping output by 'Sepal.Length.Cat' (override with `.groups` argument)
----

[source, r]
----
 `summarise()` ungrouping output (override with `.groups` argument)
----

[source, r]
----
 # A tibble: 3 x 2
   Species    std_of_avgs
   <fct>            <dbl>
 1 setosa           0.402
 2 versicolor       0.329
 3 virginica        0.255
----

As you can see, it has some pretty powerful functionality that would be more difficult to replicate (and harder to read) using base R.

== str_extract and str_extract_all

`str_extract` and `str_extract_all` are useful functions from the `stringr` package. You can install the package by running:

[source, r]
----
install.packages("stringr")
----

`str_extract` extracts the text which matches the provided regular expression or pattern. Note that this differs from grep in a major way. `grep` simply returns the index in which a pattern match was found. `str_extract` returns the actual matching text. Note that `grep` typically returns the entire line where a match was found. `str_extract` returns only the part of the line or text that matches the pattern. For example:

[source, r]
----
text <- c("cat", "mat", "spat", "spatula", "gnat")

# All 5 "lines" of text were a match.
grep(".*at", text)
----

[source, r]
----
 [1] 1 2 3 4 5
----

[source, r]
----
text <- c("cat", "mat", "spat", "spatula", "gnat")
stringr::str_extract(text, ".*at") 
----

[source, r]
----
 [1] "cat"  "mat"  "spat" "spat" "gnat"
----

As you can see, although all 5 words match our pattern and would be returned by `grep`, `str_extract` only returns the actual text that matches the pattern. In this case "spatula" is not a "full" match -- the pattern `.*at`* only captures the "spat" part of "spatula". In order to capture the rest of the word you would need to add something like `.*` to the end of the pattern:

[source, r]
----
text <- c("cat", "mat", "spat", "spatula", "gnat")
stringr::str_extract(text, ".*at.*") 
----

[source, r]
----
 [1] "cat"     "mat"     "spat"    "spatula" "gnat"
----

=== Examples

==== How can I extract the text between parenthesis in a vector of texts?

[source, r]
----
text <- c("this is easy for (you)", "there (are) challenging ones", "text is (really awesome) (ok?)")

# Search for a literal "(", followed by any amount of any text other than more parenthesis ([^()]*), followed by a literal ")".
stringr::str_extract(text, "\\([^()]*\\)")
----

[source, r]
----
 [1] "(you)"            "(are)"            "(really awesome)"
----

To get all matches, not just the first match:

[source, r]
----
text <- c("this is easy for (you)", "there (are) challenging ones", "text is (really awesome) more text (ok?)")

# Search for a literal "(", followed by any amount of any text (.*), followed by a literal ")".
stringr::str_extract_all(text, "\\([^()]*\\)")
----

[source, r]
----
 [[1]]
 [1] "(you)"
 
 [[2]]
 [1] "(are)"
 
 [[3]]
 [1] "(really awesome)" "(ok?)"
----

== lubridate

`lubridate` is a fantastic package that makes the typical tasks one would perform on dates, that much easier.

=== Examples

==== How do I convert a string "07/05/1990" to a Date?

[source, r]
----
library(lubridate)
----

[source, r]
---- 
 Attaching package: 'lubridate'
----

[source, r]
----
 The following objects are masked from 'package:data.table':
 
     hour, isoweek, mday, minute, month, quarter, second, wday, week,
     yday, year
----

[source, r]
----
 The following objects are masked from 'package:base':
 
     date, intersect, setdiff, union
----

[source, r]
----
dat <- "07/05/1990"
dat <- mdy(dat)
class(dat)
----

[source, r]
----
 [1] "Date"
----

==== How do I convert a string "31-12-1990" to a Date?

[source, r]
----
my_string <- "31-12-1990"
dat <- dmy(my_string)
dat
----

[source, r]
----
 [1] "1990-12-31"
----

[source, r]
----
class(dat)
----

[source, r]
----
 [1] "Date"
----

==== How do I convert a string "31121990" to a Date?

[source, r]
----
my_string <- "31121990"
my_date <- dmy(my_string)
my_date
----

[source, r]
----
 [1] "1990-12-31"
----

[source, r]
----
class(my_date)
----

[source, r]
----
 [1] "Date"
----

==== How do I extract the day, week, month, quarter, and year from a Date?

[source, r]
----
my_date <- dmy("31121990")
day(my_date)
----

[source, r]
----
 [1] 31
----

[source, r]
----
week(my_date)
----

[source, r]
----
 [1] 53
----

[source, r]
----
month(my_date)
----

[source, r]
----
 [1] 12
----

[source, r]
----
quarter(my_date)
----

[source, r]
----
 [1] 4
----

[source, r]
----
year(my_date)
----

[source, r]
----
 [1] 1990
----

== strep

`strrep` is a function that allows you to repeat the characters a given number of times.

=== Examples

==== How can I repeat a string of the characters ABC three times?

[source, r]
----
strrep("ABC", 3)
----

[source, r]
----
 [1] "ABCABCABC"
----

==== How can I get a vector in which A is repeated twice, B three times, and C four times?

[source, r]
----
strrep(c("A", "B", "C"), c(2,3,4))
----

[source, r]
----
 [1] "AA"   "BBB"  "CCCC"
----

== nchar

`nchar` is a function which counts the number of characters and symbols in a word or a string. Punctuation and blank spaces are counted as well.

=== Examples

==== How can I find the number of characters and or symbols in the word "Protozoa"?

[source, r]
----
nchar("Protozoa")
----

[source, r]
----
 [1] 8
----

==== How can I find the number of characters and or symbols for the following strings all at once: "pneumonoultramicroscopicsilicovolcanoconiosis", "password: DatamineRocks#stat1900@"?

[source, r]
----
string_vector <- c("pneumonoultramicroscopicsilicovolcanoconiosis", "password: DatamineRocks#stat1900@")
nchar(string_vector)
----

[source, r]
----
 [1] 45 33
----

*Fun Fact*: pneumonoultramicroscopicsilicovolcanoconiosis is the longest word in the English dictionary.

== Resources

A comprehensive cheatsheet for `lubridate` is linked below. It's an excellent resource to begin learning and working with `lubridate` quickly.

https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf[Lubridate Cheatsheet]